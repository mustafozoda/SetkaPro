

--- File: dump_all_codes.ts ---
import fs from "fs";
import path from "path";

// Extensions to include
const allowedExtensions = [".ts", ".prisma", ".json", ".md", ".env.example"];

// Specific files to exclude (regardless of extension)
const excludedFiles = ["package-lock.json", "yarn.lock"];

// Folders to skip
const excludedDirs = ["node_modules", ".git", "dist", "build", "coverage"];

const outputFile = "code_dump.txt";
const outputStream = fs.createWriteStream(outputFile, { flags: "w" });

function shouldInclude(file: string): boolean {
  const extOk = allowedExtensions.some((ext) => file.endsWith(ext));
  const nameOk = !excludedFiles.includes(path.basename(file));
  return extOk && nameOk;
}

function shouldExcludeDir(dirName: string): boolean {
  return excludedDirs.includes(dirName);
}

function collectFiles(dir: string) {
  const items = fs.readdirSync(dir, { withFileTypes: true });

  for (const item of items) {
    const fullPath = path.join(dir, item.name);

    if (item.isDirectory()) {
      if (!shouldExcludeDir(item.name)) {
        collectFiles(fullPath);
      }
    } else if (shouldInclude(item.name)) {
      try {
        const content = fs.readFileSync(fullPath, "utf-8");

        outputStream.write(`\n\n--- File: ${fullPath} ---\n`);
        outputStream.write(content);
      } catch (err) {
        console.error(`❌ Failed to read ${fullPath}:`, err);
      }
    }
  }
}

collectFiles(".");
outputStream.end(() => {
  console.log(`✅ Code dump saved to ${outputFile}`);
});
// npx ts-node dump_all_codes.ts


--- File: package.json ---
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@mrleebo/prisma-ast": "^0.12.1",
    "@prisma/client": "^6.5.0",
    "backend": "file:",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "exceljs": "^4.4.0",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "nodemailer": "^6.10.0",
    "pdfkit": "^0.16.0",
    "prisma": "^6.5.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "@types/bcryptjs": "^3.0.0",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.14.0",
    "@types/nodemailer": "^6.4.17",
    "@types/pdfkit": "^0.13.9",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "nodemon": "^3.1.9",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.2"
  }
}


--- File: prisma\schema.prisma ---
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  OWNER
  MANAGER
  WORKER
  DRIVER
  COOK
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  phone     String
  address   String
  password  String
  role      Role
  createdAt DateTime @default(now())

  productions  Production[]
  invoicesSold Invoice[]     @relation("SellerInvoices")
  salaries     Salary[]
  machineLogs  MachineLog[]
  activityLogs ActivityLog[]
}

model Client {
  id        String   @id @default(uuid())
  name      String
  email     String?
  phone     String?
  address   String?
  createdAt DateTime @default(now())

  invoices Invoice[]
}

model MeshType {
  id             String   @id @default(uuid())
  type           String // e.g. "10x10"
  form           String? // optional, like "roll" or "sheet"
  wireType       String // e.g. "3mm"
  weightPerPiece Float // kg per mesh piece
  priceForClient Float
  priceForWorker Float
  currentStock   Int      @default(0) // dynamic stock tracking
  stockThreshold Int      @default(0) // alert if low
  createdAt      DateTime @default(now())

  productions Production[]
  invoices    Invoice[]
}

model Wire {
  id         String   @id @default(uuid())
  wireType   String // e.g. "3mm"
  quantityKg Float
  usedKg     Float    @default(0)
  createdAt  DateTime @default(now())
}

model Production {
  id         String   @id @default(uuid())
  userId     String
  meshTypeId String
  quantity   Int
  startedAt  DateTime
  finishedAt DateTime
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id])
  meshType MeshType @relation(fields: [meshTypeId], references: [id])
}

model Invoice {
  id           String   @id @default(uuid())
  clientId     String
  sellerId     String
  meshTypeId   String
  quantity     Int
  pricePerUnit Float
  total        Float
  amountPaid   Float    @default(0)
  isPaid       Boolean  @default(false)
  dueAmount    Float    @default(0)
  createdAt    DateTime @default(now())

  client     Client       @relation(fields: [clientId], references: [id])
  seller     User         @relation("SellerInvoices", fields: [sellerId], references: [id])
  meshType   MeshType     @relation(fields: [meshTypeId], references: [id])
  PaymentLog PaymentLog[]
}

model Salary {
  id        String   @id @default(uuid())
  userId    String
  month     String // e.g. "2025-04"
  amount    Float
  paid      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

model Finance {
  id          String   @id @default(uuid())
  type        String // "income", "expense"
  category    String // "wire", "salary", "sale", etc.
  amount      Float
  description String?
  createdAt   DateTime @default(now())
}

model Machine {
  id          String    @id @default(uuid())
  name        String
  description String?
  inUse       Boolean   @default(false)
  lastUsed    DateTime?
  createdAt   DateTime  @default(now())

  logs MachineLog[]
}

model MachineLog {
  id        String    @id @default(uuid())
  machineId String
  userId    String?
  startedAt DateTime
  endedAt   DateTime?

  machine Machine @relation(fields: [machineId], references: [id])
  user    User?   @relation(fields: [userId], references: [id])
}

model ActivityLog {
  id        String   @id @default(uuid())
  userId    String
  action    String
  module    String // e.g. "Invoice", "Mesh", etc.
  details   String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

model Localization {
  id        String   @id @default(uuid())
  key       String
  en        String
  ru        String
  createdAt DateTime @default(now())
}

model PaymentLog {
  id        String   @id @default(uuid())
  invoiceId String
  amount    Float
  paidAt    DateTime @default(now())

  invoice Invoice @relation(fields: [invoiceId], references: [id])
}


--- File: scripts\listModels.ts ---
import fs from "fs";
import path from "path";

const schemaPath = path.join(__dirname, "../prisma/schema.prisma");
const schema = fs.readFileSync(schemaPath, "utf-8");

// Match all models
const matches = Array.from(schema.matchAll(/model (\w+) \{/g));
const modelNames = matches.map((m) => m[1]);

// Output JSON format
const jsonOutput = {
  models: modelNames,
};

console.log(JSON.stringify(jsonOutput, null, 2));
// npx ts-node scripts/listModels.ts


--- File: scripts\parseSchema.ts ---
import fs from "fs";
import path from "path";
import { getSchema } from "@mrleebo/prisma-ast";

const schemaPath = path.join(__dirname, "../prisma/schema.prisma");
const schema = fs.readFileSync(schemaPath, "utf-8");

const ast = getSchema(schema);

const models = ast.list
  .filter((node: any) => node.type === "model")
  .map((model: any) => ({
    name: model.name,
    fields: model.properties
      .filter((p: any) => p.type === "field")
      .map((field: any) => ({
        name: field.name,
        type: field.fieldType,
        isRequired: !field.optional,
        isArray: !!field.array,
        isRelation:
          field.attributes?.some((a: any) => a.name === "relation") || false,
        default:
          field.attributes?.find((a: any) => a.name === "default")?.args?.[0]
            ?.value ?? null,
      })),
  }));

const jsonOutput = JSON.stringify(models, null, 2);

// ✅ Save to file
const outputPath = path.join(__dirname, "models.json");
fs.writeFileSync(outputPath, jsonOutput, "utf-8");

// ✅ Also print to console
console.log(jsonOutput);

// npx ts-node scripts/parseSchema.ts


--- File: src\app.ts ---
import express from "express";
import cors from "cors";
import { errorHandler } from "./middleware/errorHandler";
import authRoutes from "./routes/auth.routes";
import userRoutes from "./routes/user.routes";
import clientRoutes from "./routes/client.routes";
import meshRoutes from "./routes/mesh.routes";
import wireRoutes from "./routes/wire.routes";
import productionRoutes from "./routes/production.routes";
import invoiceRoutes from "./routes/invoice.routes";
import salaryRoutes from "./routes/salary.routes";
import machineRoutes from "./routes/machine.routes";
import financeRoutes from "./routes/finance.routes";
import reportRoutes from "./routes/report.routes";
import localizationRoutes from "./routes/localization.routes";
import { detectLanguage } from "./middleware/lang";
import { swaggerUi, swaggerSpec } from "./docs/swagger";

const app = express();

// Middlewares
app.use(cors());
app.use(express.json());

// Swagger
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/users", userRoutes);
app.use("/api/clients", clientRoutes);
app.use("/api/meshes", meshRoutes);
app.use("/api/wires", wireRoutes);
app.use("/api/production", productionRoutes);
app.use("/api/invoices", invoiceRoutes);
app.use("/api/salaries", salaryRoutes);
app.use("/api/machines", machineRoutes);
app.use("/api/finance", financeRoutes);
app.use("/api/reports", reportRoutes);
app.use("/api/localization", localizationRoutes);

app.use(detectLanguage);

// Global error handler
app.use(errorHandler);

export default app;


--- File: src\config\env.ts ---
import dotenv from "dotenv";
dotenv.config();

function getEnv(key: string): string {
  const value = process.env[key];
  if (!value) throw new Error(`❌ ENV ${key} is not defined`);
  return value;
}

export const ENV = {
  PORT: Number(process.env.PORT || 5000),
  JWT_SECRET: getEnv("JWT_SECRET"),
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || "7d",
  EMAIL_FROM: getEnv("EMAIL_FROM"),
  EMAIL_USER: getEnv("EMAIL_USER"),
  EMAIL_PASS: getEnv("EMAIL_PASS"),
};


--- File: src\config\prisma.ts ---
import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient();


--- File: src\controllers\auth.controller.ts ---
import { Request, Response, NextFunction } from "express";
import { loginUser, registerUser } from "../services/auth.service";

export const register = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await registerUser(req.body);
    res.status(201).json(data);
  } catch (err) {
    next(err);
  }
};

export const login = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await loginUser(req.body);
    res.status(200).json(data);
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\client.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as clientService from "../services/client.service";

export const createClient = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const client = await clientService.createClient(req.body);
    res.status(201).json(client);
  } catch (err) {
    next(err);
  }
};

export const getAllClients = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const clients = await clientService.getAllClients();
    res.json(clients);
  } catch (err) {
    next(err);
  }
};

export const getClientById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const client = await clientService.getClientById(req.params.id);
    res.json(client);
  } catch (err) {
    next(err);
  }
};

export const updateClient = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const updated = await clientService.updateClient(req.params.id, req.body);
    res.json(updated);
  } catch (err) {
    next(err);
  }
};

export const deleteClient = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await clientService.deleteClient(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\finance.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as financeService from "../services/finance.service";

export const createFinanceEntry = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const entry = await financeService.createFinanceEntry(req.body);
    res.status(201).json(entry);
  } catch (err) {
    next(err);
  }
};

export const getAllFinance = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const entries = await financeService.getAllFinance();
    res.json(entries);
  } catch (err) {
    next(err);
  }
};

export const getFinanceByMonth = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const entries = await financeService.getFinanceByMonth(req.params.month);
    res.json(entries);
  } catch (err) {
    next(err);
  }
};

export const deleteFinanceEntry = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await financeService.deleteFinanceEntry(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\invoice.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as invoiceService from "../services/invoice.service";

export const createInvoice = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const invoice = await invoiceService.createInvoice(req.user!.id, req.body);
    res.status(201).json(invoice);
  } catch (err) {
    next(err);
  }
};

export const getAllInvoices = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const invoices = await invoiceService.getAllInvoices();
    res.json(invoices);
  } catch (err) {
    next(err);
  }
};

export const getInvoiceById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const invoice = await invoiceService.getInvoiceById(req.params.id);
    res.json(invoice);
  } catch (err) {
    next(err);
  }
};

export const deleteInvoice = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await invoiceService.deleteInvoice(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};

export const updateInvoicePayment = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await invoiceService.addPayment(
      req.params.id,
      req.body.amount
    );
    res.json(result);
  } catch (err) {
    next(err);
  }
};

export const generateInvoicePDFRoute = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const buffer = await invoiceService.getInvoicePDF(req.params.id);
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", "inline; filename=invoice.pdf");
    res.send(buffer);
  } catch (err) {
    next(err);
  }
};

export const sendInvoiceByEmail = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await invoiceService.emailInvoice(req.params.id);
    res.json({ message: "Email sent!" });
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\machine.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as machineService from "../services/machine.service";

export const createMachine = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const machine = await machineService.createMachine(req.body);
    res.status(201).json(machine);
  } catch (err) {
    next(err);
  }
};

export const getAllMachines = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const machines = await machineService.getAllMachines();
    res.json(machines);
  } catch (err) {
    next(err);
  }
};

export const getMachineById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const machine = await machineService.getMachineById(req.params.id);
    res.json(machine);
  } catch (err) {
    next(err);
  }
};

export const updateMachine = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const updated = await machineService.updateMachine(req.params.id, req.body);
    res.json(updated);
  } catch (err) {
    next(err);
  }
};

export const deleteMachine = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await machineService.deleteMachine(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};

export const createMachineLog = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const log = await machineService.createMachineLog(
      req.params.id,
      req.user!.id,
      req.body
    );
    res.status(201).json(log);
  } catch (err) {
    next(err);
  }
};

export const getMachineLogs = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const logs = await machineService.getMachineLogs(req.params.id);
    res.json(logs);
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\mesh.controller.ts ---
import { Request, Response } from "express";
import { prisma } from "../config/prisma";

// Create a new mesh type
export const createMeshType = async (req: Request, res: Response) => {
  try {
    const mesh = await prisma.meshType.create({ data: req.body });
    res.status(201).json(mesh);
  } catch (err) {
    res.status(500).json({ message: "Failed to create mesh type", error: err });
  }
};

// Get all mesh types
export const getAllMeshTypes = async (req: Request, res: Response) => {
  try {
    const meshes = await prisma.meshType.findMany();
    res.status(200).json(meshes);
  } catch (err) {
    res
      .status(500)
      .json({ message: "Failed to retrieve mesh types", error: err });
  }
};

// Get a specific mesh type by ID
export const getMeshTypeById = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const mesh = await prisma.meshType.findUnique({
      where: { id: req.params.id },
    });
    if (!mesh) {
      res.status(404).json({ message: "Mesh type not found" });
      return;
    }
    res.status(200).json(mesh);
  } catch (err) {
    res.status(500).json({ message: "Error getting mesh type", error: err });
  }
};

// Update a mesh type
export const updateMeshType = async (req: Request, res: Response) => {
  try {
    const mesh = await prisma.meshType.update({
      where: { id: req.params.id },
      data: req.body,
    });
    res.status(200).json(mesh);
  } catch (err) {
    res.status(500).json({ message: "Failed to update mesh type", error: err });
  }
};

// Delete a mesh type
export const deleteMeshType = async (req: Request, res: Response) => {
  try {
    await prisma.meshType.delete({ where: { id: req.params.id } });
    res.status(204).send();
  } catch (err) {
    res.status(500).json({ message: "Failed to delete mesh type", error: err });
  }
};


--- File: src\controllers\meshRate.controller.ts ---
import { Request, Response } from "express";
import prisma from "../prisma/client";

/**
 * @swagger
 * /api/meshRate:
 *   get:
 *     summary: Get all mesh rates
 *     description: Returns a list of mesh rates from the database
 *     responses:
 *       200:
 *         description: List of mesh rates
 */
export const getRates = async (req: Request, res: Response) => {
  try {
    const rates = await prisma.meshRate.findMany();
    res.json(rates);
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch mesh rates" });
  }
};

/**
 * @swagger
 * /api/meshRate/create:
 *   post:
 *     summary: Create a new mesh rate
 *     description: Creates a new mesh rate in the database
 *     responses:
 *       201:
 *         description: Mesh rate successfully added
 *       400:
 *         description: Invalid request body
 */
export const addRate = async (req: Request, res: Response) => {
  const { meshType, rate, price } = req.body;

  if (!meshType || !rate || !price) {
    return res.status(400).json({ error: "Missing required fields" });
  }

  try {
    const newRate = await prisma.meshRate.create({
      data: { meshType, rate, price },
    });
    res.status(201).json(newRate);
  } catch (err) {
    res.status(500).json({ error: "Failed to create mesh rate" });
  }
};


--- File: src\controllers\production.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as productionService from "../services/production.service";

export const createProduction = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await productionService.createProduction(
      req.user!.id,
      req.body
    );
    res.status(201).json(data);
  } catch (err) {
    next(err);
  }
};

export const getAllProductions = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await productionService.getAllProductions();
    res.json(data);
  } catch (err) {
    next(err);
  }
};

export const getProductionByDate = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { date } = req.query;
    const data = await productionService.getProductionByDate(date as string);
    res.json(data);
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\report.controller.ts ---
// controllers/report.controller.ts
import { Request, Response, NextFunction } from "express";
import * as reportService from "../services/report.service";

export const getTopSellingMeshes = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await reportService.getTopSellingMeshes();
    res.json(result);
  } catch (err) {
    next(err);
  }
};

export const getTopClients = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await reportService.getTopClients();
    res.json(result);
  } catch (err) {
    next(err);
  }
};

export const getTopWorkers = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await reportService.getTopWorkers();
    res.json(result);
  } catch (err) {
    next(err);
  }
};

export const getCurrentStock = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await reportService.getCurrentStock();
    res.json(result);
  } catch (err) {
    next(err);
  }
};

export const getWireEfficiency = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const result = await reportService.getWireEfficiency();
    res.json(result);
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\salary.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as salaryService from "../services/salary.service";

export const createSalary = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await salaryService.createSalary(req.body);
    res.status(201).json(data);
  } catch (err) {
    next(err);
  }
};

export const getAllSalaries = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await salaryService.getAllSalaries();
    res.json(data);
  } catch (err) {
    next(err);
  }
};

export const getSalariesByMonth = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await salaryService.getSalariesByMonth(req.params.month);
    res.json(data);
  } catch (err) {
    next(err);
  }
};

export const markSalaryAsPaid = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const data = await salaryService.markSalaryAsPaid(req.params.id);
    res.json(data);
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\user.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as userService from "../services/user.service";

export const getAllUsers = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const users = await userService.getAllUsers();
    res.json(users);
  } catch (err) {
    next(err);
  }
};

export const getUserById = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await userService.getUserById(req.params.id);
    res.json(user);
  } catch (err) {
    next(err);
  }
};

export const updateUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const updated = await userService.updateUser(req.params.id, req.body);
    res.json(updated);
  } catch (err) {
    next(err);
  }
};

export const deleteUser = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await userService.deleteUser(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};


--- File: src\controllers\wire.controller.ts ---
import { Request, Response, NextFunction } from "express";
import * as wireService from "../services/wire.service";

export const createWire = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const wire = await wireService.createWire(req.body);
    res.status(201).json(wire);
  } catch (err) {
    next(err);
  }
};

export const getAllWires = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const list = await wireService.getAllWires();
    res.json(list);
  } catch (err) {
    next(err);
  }
};

export const getWireBalanceByType = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const balance = await wireService.getRemainingWireByType(
      req.params.wireType
    );
    res.json({ wireType: req.params.wireType, remainingKg: balance });
  } catch (err) {
    next(err);
  }
};

export const deleteWire = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    await wireService.deleteWire(req.params.id);
    res.status(204).send();
  } catch (err) {
    next(err);
  }
};


--- File: src\docs\models.md ---
# 📦 Prisma Model Overview

## User

- **Fields:** id, name, email, password, role, createdAt
- **Purpose:** Authentication and access control

## Employee

- **Fields:** id, name, role, salary, createdAt
- **Relations:** MeshProductions, Invoices
- **Purpose:** Track factory employees

## Wire

- **Fields:** type, diameter, quantityKg, pricePerKg, supplier, createdAt
- **Purpose:** Manage inventory of raw wire

## MeshProduction

- **Fields:** meshType, quantity, wireUsedKg, wireDiameter, employeeId, createdAt
- **Relations:** ↔ Employee
- **Purpose:** Track daily mesh production

## Client

- **Fields:** name, phone, address, createdAt
- **Relations:** ↔ Invoice[]
- **Purpose:** Customer details

## Invoice

- **Fields:** id, total, createdAt
- **Relations:** ↔ Client, ↔ Employee, ↔ SaleItems
- **Purpose:** Represents a sale

## SaleItem

- **Fields:** meshType, quantity, unitPrice
- **Relations:** ↔ Invoice
- **Purpose:** Individual mesh items sold


--- File: src\docs\swagger.ts ---
// docs/swagger.ts
import swaggerJsdoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "Factory Management API",
      version: "1.0.0",
      description:
        "Mesh production, payroll, inventory, and client management system",
    },
    servers: [
      {
        url: "http://localhost:3000",
        description: "Local server",
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
    },
    security: [{ bearerAuth: [] }],
  },
  apis: ["./src/routes/*.ts"],
};

const swaggerSpec = swaggerJsdoc(options);

export { swaggerUi, swaggerSpec };


--- File: src\i18n\messages.ts ---
export type Lang = "en" | "ru";

type MessageStructure = {
  auth: {
    loginSuccess: string;
    registerSuccess: string;
  };
  invoice: {
    created: string;
    paid: string;
    title: string;
    client: string;
    meshType: string;
    quantity: string;
    unitPrice: string;
    total: string;
    date: string;
    emailSubject: string;
    emailBody: string;
  };
  errors: {
    notFound: string;
    unauthorized: string;
  };
};

export const messages: Record<Lang, MessageStructure> = {
  en: {
    auth: {
      loginSuccess: "Login successful",
      registerSuccess: "User registered successfully",
    },
    invoice: {
      created: "Invoice has been created",
      paid: "Payment recorded",
      title: "Invoice",
      client: "Client",
      meshType: "Mesh Type",
      quantity: "Quantity",
      unitPrice: "Price per unit",
      total: "Total",
      date: "Date",
      emailSubject: "Your Invoice",
      emailBody: "Thank you for your purchase. See attached invoice.",
    },
    errors: {
      notFound: "Not found",
      unauthorized: "Unauthorized",
    },
  },
  ru: {
    auth: {
      loginSuccess: "Вход выполнен успешно",
      registerSuccess: "Пользователь зарегистрирован",
    },
    invoice: {
      created: "Счет был создан",
      paid: "Платеж зарегистрирован",
      title: "Счет",
      client: "Клиент",
      meshType: "Тип сетки",
      quantity: "Количество",
      unitPrice: "Цена за единицу",
      total: "Итого",
      date: "Дата",
      emailSubject: "Ваш счет",
      emailBody: "Спасибо за покупку. Счет прилагается.",
    },
    errors: {
      notFound: "Не найдено",
      unauthorized: "Нет доступа",
    },
  },
};

export const t = (key: string, lang: Lang = "en"): string => {
  const parts = key.split(".");
  let val: any = messages[lang as Lang];

  for (const part of parts) {
    val = val?.[part];
    if (val === undefined) break;
  }

  return typeof val === "string" ? val : key;
};


--- File: src\index.ts ---
import app from "./app";
import { ENV } from "./config/env";

const PORT = ENV.PORT;

app.listen(PORT, () => {
  console.log(`🚀 Server running at http://localhost:${PORT}`);
  console.log(`📚 Swagger docs at http://localhost:${PORT}/api-docs`);
});


--- File: src\middleware\auth.ts ---
import jwt from "jsonwebtoken";
import { Request, Response, NextFunction } from "express";
import { prisma } from "../config/prisma";
import { ENV } from "../config/env";
import { Role } from "@prisma/client";

export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ message: "Unauthorized: Token missing" });
      return;
    }

    const token = authHeader.split(" ")[1];
    const decoded: any = jwt.verify(token, ENV.JWT_SECRET);

    const user = await prisma.user.findUnique({ where: { id: decoded.id } });
    if (!user) {
      res.status(401).json({ message: "Unauthorized: Invalid user" });
      return;
    }

    req.user = user;
    next();
  } catch (err) {
    res.status(401).json({ message: "Unauthorized: Invalid token" });
  }
};

export const authorize = (roles: Role[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const user = req.user;
    if (!user || !roles.includes(user.role)) {
      res.status(403).json({ message: "Forbidden" });
      return;
    }
    next();
  };
};


--- File: src\middleware\errorHandler.ts ---
import { Request, Response, NextFunction } from "express";

export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error("🔥 Error:", err);
  const status = err.status || 500;
  const message = err.message || "Internal Server Error";

  res.status(status).json({
    success: false,
    message,
    ...(process.env.NODE_ENV !== "production" && { stack: err.stack }),
  });
};


--- File: src\middleware\lang.ts ---
import { Request, Response, NextFunction } from "express";

export const detectLanguage = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const lang = req.headers["accept-language"];
  req.lang = lang?.startsWith("ru") ? "ru" : "en";
  next();
};


--- File: src\prisma\client.ts ---
// =============================
// 2. CLIENT - prisma/client.ts
// =============================

import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
export default prisma;


--- File: src\routes\auth.routes.ts ---
import { Router } from "express";
import { login, register } from "../controllers/auth.controller";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Auth
 *   description: Authentication & Registration
 */

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user (Owner only)
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [name, email, password, role, phone, address]
 *             properties:
 *               name:
 *                 type: string
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [OWNER, MANAGER, WORKER, DRIVER, COOK]
 *     responses:
 *       201:
 *         description: User registered
 *       400:
 *         description: Error
 */
router.post("/register", register);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Login a user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [email, password]
 *             properties:
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: User logged in
 *       401:
 *         description: Invalid credentials
 */
router.post("/login", login);

export default router;


--- File: src\routes\client.routes.ts ---
import { Router } from "express";
import {
  createClient,
  getAllClients,
  getClientById,
  updateClient,
  deleteClient,
} from "../controllers/client.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";
console.log(Role.OWNER);
const router = Router();

/**
 * @swagger
 * tags:
 *   name: Clients
 *   description: Manage client database
 */

router.use(authenticate);

/**
 * @swagger
 * /api/clients:
 *   post:
 *     summary: Add a new client
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [name]
 *             properties:
 *               name:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *               email:
 *                 type: string
 *     responses:
 *       201:
 *         description: Created client
 */
router.post("/", authorize([Role.OWNER, Role.MANAGER]), createClient);

/**
 * @swagger
 * /api/clients:
 *   get:
 *     summary: Get all clients
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of clients
 */
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllClients);

/**
 * @swagger
 * /api/clients/{id}:
 *   get:
 *     summary: Get client by ID
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Client found
 */
router.get("/:id", authorize([Role.OWNER, Role.MANAGER]), getClientById);

/**
 * @swagger
 * /api/clients/{id}:
 *   put:
 *     summary: Update client
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *               email:
 *                 type: string
 *     responses:
 *       200:
 *         description: Client updated
 */
router.put("/:id", authorize([Role.OWNER, Role.MANAGER]), updateClient);

/**
 * @swagger
 * /api/clients/{id}:
 *   delete:
 *     summary: Delete client
 *     tags: [Clients]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       204:
 *         description: Deleted
 */
router.delete("/:id", authorize([Role.OWNER, Role.MANAGER]), deleteClient);

export default router;


--- File: src\routes\finance.routes.ts ---
// routes/finance.routes.ts
import { Router } from "express";
import {
  createFinanceEntry,
  getAllFinance,
  getFinanceByMonth,
  deleteFinanceEntry,
} from "../controllers/finance.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Finance
 *   description: Track income and expenses
 */

router.use(authenticate);

/**
 * @swagger
 * /api/finance:
 *   post:
 *     summary: Create a finance entry
 *     tags: [Finance]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [type, category, amount]
 *             properties:
 *               type:
 *                 type: string
 *                 enum: [income, expense]
 *               category:
 *                 type: string
 *               amount:
 *                 type: number
 *               description:
 *                 type: string
 *     responses:
 *       201:
 *         description: Finance entry created
 */
router.post("/", authorize([Role.OWNER]), createFinanceEntry);

/**
 * @swagger
 * /api/finance:
 *   get:
 *     summary: Get all finance entries
 *     tags: [Finance]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of finance records
 */
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllFinance);

/**
 * @swagger
 * /api/finance/month/{month}:
 *   get:
 *     summary: Get finance entries by month
 *     tags: [Finance]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: month
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *           example: 2025-04
 *     responses:
 *       200:
 *         description: Monthly finance data
 */
router.get("/month/:month", authorize([Role.OWNER]), getFinanceByMonth);

/**
 * @swagger
 * /api/finance/{id}:
 *   delete:
 *     summary: Delete a finance entry
 *     tags: [Finance]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       204:
 *         description: Entry deleted
 */
router.delete("/:id", authorize([Role.OWNER]), deleteFinanceEntry);

export default router;


--- File: src\routes\invoice.routes.ts ---
import { Router } from "express";
import {
  createInvoice,
  getAllInvoices,
  getInvoiceById,
  deleteInvoice,
  updateInvoicePayment,
  generateInvoicePDFRoute,
  sendInvoiceByEmail,
} from "../controllers/invoice.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Invoices
 *   description: Manage mesh sales and invoices
 */

router.use(authenticate);

/**
 * @swagger
 * /api/invoices:
 *   post:
 *     summary: Create a new invoice
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [clientId, meshTypeId, quantity, pricePerUnit]
 *             properties:
 *               clientId:
 *                 type: string
 *               meshTypeId:
 *                 type: string
 *               quantity:
 *                 type: number
 *               pricePerUnit:
 *                 type: number
 *               amountPaid:
 *                 type: number
 *     responses:
 *       201:
 *         description: Invoice created
 */
router.post(
  "/",
  authorize([Role.WORKER, Role.MANAGER, Role.OWNER]),
  createInvoice
);

/**
 * @swagger
 * /api/invoices:
 *   get:
 *     summary: Get all invoices
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of all invoices
 */
router.get("/", authorize([Role.MANAGER, Role.OWNER]), getAllInvoices);

/**
 * @swagger
 * /api/invoices/{id}:
 *   get:
 *     summary: Get invoice by ID
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Invoice details
 */
router.get("/:id", authorize([Role.MANAGER, Role.OWNER]), getInvoiceById);

/**
 * @swagger
 * /api/invoices/{id}:
 *   delete:
 *     summary: Delete an invoice
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       204:
 *         description: Invoice deleted
 */
router.delete("/:id", authorize([Role.OWNER]), deleteInvoice);

/**
 * @swagger
 * /api/invoices/{id}/pay:
 *   patch:
 *     summary: Add payment to an invoice
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [amount]
 *             properties:
 *               amount:
 *                 type: number
 *     responses:
 *       200:
 *         description: Invoice updated
 */
router.patch(
  "/:id/pay",
  authorize([Role.MANAGER, Role.OWNER]),
  updateInvoicePayment
);

/**
 * @swagger
 * /api/invoices/{id}/pdf:
 *   get:
 *     summary: Download invoice as PDF
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Returns PDF file
 */
router.get(
  "/:id/pdf",
  authorize([Role.MANAGER, Role.OWNER]),
  generateInvoicePDFRoute
);

/**
 * @swagger
 * /api/invoices/{id}/email:
 *   post:
 *     summary: Send invoice to client via email
 *     tags: [Invoices]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Email sent
 */
router.post(
  "/:id/email",
  authorize([Role.MANAGER, Role.OWNER]),
  sendInvoiceByEmail
);

export default router;


--- File: src\routes\localization.routes.ts ---
import { Router } from "express";

const router = Router();

router.get("/", (req, res) => {
  res.json({ message: "Localization routes will be here soon." });
});

export default router;


--- File: src\routes\machine.routes.ts ---
// routes/machine.routes.ts
import { Router } from "express";
import {
  createMachine,
  getAllMachines,
  getMachineById,
  updateMachine,
  deleteMachine,
  createMachineLog,
  getMachineLogs,
} from "../controllers/machine.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Machines
 *   description: Manage machines and logs
 */

router.use(authenticate);

router.post("/", authorize([Role.OWNER, Role.MANAGER]), createMachine);
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllMachines);
router.get("/:id", authorize([Role.OWNER, Role.MANAGER]), getMachineById);
router.put("/:id", authorize([Role.OWNER]), updateMachine);
router.delete("/:id", authorize([Role.OWNER]), deleteMachine);

router.post(
  "/:id/logs",
  authorize([Role.WORKER, Role.MANAGER, Role.OWNER]),
  createMachineLog
);
router.get("/:id/logs", authorize([Role.OWNER, Role.MANAGER]), getMachineLogs);

export default router;


--- File: src\routes\mesh.routes.ts ---
import { Router } from "express";
import {
  createMeshType,
  getAllMeshTypes,
  getMeshTypeById,
  updateMeshType,
  deleteMeshType,
} from "../controllers/mesh.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Mesh
 *   description: Mesh types and pricing
 */

router.use(authenticate);

/**
 * @swagger
 * /api/meshes:
 *   post:
 *     summary: Create mesh type
 *     tags: [Mesh]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [type, wireType, priceForClient, priceForWorker, weightPerPiece]
 *             properties:
 *               type:
 *                 type: string
 *                 example: "10x10"
 *               form:
 *                 type: string
 *                 example: "roll"
 *               wireType:
 *                 type: string
 *                 example: "3mm"
 *               priceForClient:
 *                 type: number
 *               priceForWorker:
 *                 type: number
 *               weightPerPiece:
 *                 type: number
 *               stockThreshold:
 *                 type: number
 *     responses:
 *       201:
 *         description: Created mesh type
 */
router.post("/", authorize([Role.OWNER]), createMeshType);

/**
 * @swagger
 * /api/meshes:
 *   get:
 *     summary: Get all mesh types
 *     tags: [Mesh]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of mesh types
 */
router.get(
  "/",
  authorize([Role.OWNER, Role.MANAGER, Role.WORKER]),
  getAllMeshTypes
);

/**
 * @swagger
 * /api/meshes/{id}:
 *   get:
 *     summary: Get mesh type by ID
 *     tags: [Mesh]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Mesh type details
 */
router.get("/:id", authorize([Role.OWNER, Role.MANAGER]), getMeshTypeById);

/**
 * @swagger
 * /api/meshes/{id}:
 *   put:
 *     summary: Update mesh type
 *     tags: [Mesh]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               type:
 *                 type: string
 *               form:
 *                 type: string
 *               wireType:
 *                 type: string
 *               priceForClient:
 *                 type: number
 *               priceForWorker:
 *                 type: number
 *               weightPerPiece:
 *                 type: number
 *               currentStock:
 *                 type: number
 *               stockThreshold:
 *                 type: number
 *     responses:
 *       200:
 *         description: Updated mesh type
 */
router.put("/:id", authorize([Role.OWNER]), updateMeshType);

/**
 * @swagger
 * /api/meshes/{id}:
 *   delete:
 *     summary: Delete mesh type
 *     tags: [Mesh]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *     responses:
 *       204:
 *         description: Deleted
 */
router.delete("/:id", authorize([Role.OWNER]), deleteMeshType);

export default router;


--- File: src\routes\production.routes.ts ---
import { Router } from "express";
import {
  createProduction,
  getAllProductions,
  getProductionByDate,
} from "../controllers/production.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Production
 *   description: Mesh production logs by workers
 */

router.use(authenticate);

/**
 * @swagger
 * /api/production:
 *   post:
 *     summary: Add a production entry
 *     tags: [Production]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [meshTypeId, quantity, startedAt, finishedAt]
 *             properties:
 *               meshTypeId:
 *                 type: string
 *               quantity:
 *                 type: number
 *               startedAt:
 *                 type: string
 *               finishedAt:
 *                 type: string
 *     responses:
 *       201:
 *         description: Production entry created
 */
router.post(
  "/",
  authorize([Role.WORKER, Role.MANAGER, Role.OWNER]),
  createProduction
);

/**
 * @swagger
 * /api/production:
 *   get:
 *     summary: Get all production logs
 *     tags: [Production]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of logs
 */
router.get("/", authorize([Role.MANAGER, Role.OWNER]), getAllProductions);

/**
 * @swagger
 * /api/production?date=YYYY-MM-DD:
 *   get:
 *     summary: Get production by date
 *     tags: [Production]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: date
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Production for that day
 */
router.get("/date", authorize([Role.MANAGER, Role.OWNER]), getProductionByDate);

export default router;


--- File: src\routes\report.routes.ts ---
// routes/report.routes.ts
import { Router } from "express";
import {
  getTopSellingMeshes,
  getTopClients,
  getTopWorkers,
  getCurrentStock,
  getWireEfficiency,
} from "../controllers/report.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Reports
 *   description: Analytics and insights
 */

router.use(authenticate);

router.get(
  "/top-meshes",
  authorize([Role.OWNER, Role.MANAGER]),
  getTopSellingMeshes
);
router.get(
  "/top-clients",
  authorize([Role.OWNER, Role.MANAGER]),
  getTopClients
);
router.get(
  "/top-workers",
  authorize([Role.OWNER, Role.MANAGER]),
  getTopWorkers
);
router.get("/stock", authorize([Role.OWNER, Role.MANAGER]), getCurrentStock);
router.get("/wire-efficiency", authorize([Role.OWNER]), getWireEfficiency);

export default router;


--- File: src\routes\salary.routes.ts ---
import { Router } from "express";
import {
  createSalary,
  getAllSalaries,
  getSalariesByMonth,
  markSalaryAsPaid,
} from "../controllers/salary.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Salaries
 *   description: Manage employee salary and payroll
 */

router.use(authenticate);

/**
 * @swagger
 * /api/salaries:
 *   post:
 *     summary: Create a new salary record
 *     tags: [Salaries]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [userId, month, amount]
 *             properties:
 *               userId:
 *                 type: string
 *               month:
 *                 type: string
 *               amount:
 *                 type: number
 *     responses:
 *       201:
 *         description: Salary created
 */
router.post("/", authorize([Role.OWNER]), createSalary);

/**
 * @swagger
 * /api/salaries:
 *   get:
 *     summary: Get all salary records
 *     tags: [Salaries]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of salaries
 */
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllSalaries);

/**
 * @swagger
 * /api/salaries/month/{month}:
 *   get:
 *     summary: Get salary records by month (e.g. 2025-04)
 *     tags: [Salaries]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: month
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Salaries for given month
 */
router.get(
  "/month/:month",
  authorize([Role.OWNER, Role.MANAGER]),
  getSalariesByMonth
);

/**
 * @swagger
 * /api/salaries/{id}/pay:
 *   patch:
 *     summary: Mark salary as paid
 *     tags: [Salaries]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Salary marked as paid
 */
router.patch("/:id/pay", authorize([Role.OWNER]), markSalaryAsPaid);

export default router;


--- File: src\routes\user.routes.ts ---
import { Router } from "express";
import {
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
} from "../controllers/user.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Users
 *   description: Manage employees (by owner or manager)
 */

router.use(authenticate); // All routes require auth

/**
 * @swagger
 * /api/users:
 *   get:
 *     summary: Get all users
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of users
 */
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllUsers);

/**
 * @swagger
 * /api/users/{id}:
 *   get:
 *     summary: Get user by ID
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: User object
 */
router.get("/:id", authorize([Role.OWNER, Role.MANAGER]), getUserById);

/**
 * @swagger
 * /api/users/{id}:
 *   put:
 *     summary: Update user
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               phone:
 *                 type: string
 *               address:
 *                 type: string
 *               role:
 *                 type: string
 *     responses:
 *       200:
 *         description: Updated user
 */
router.put("/:id", authorize([Role.OWNER]), updateUser);

/**
 * @swagger
 * /api/users/{id}:
 *   delete:
 *     summary: Delete user
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       204:
 *         description: Deleted
 */
router.delete("/:id", authorize([Role.OWNER]), deleteUser);

export default router;


--- File: src\routes\wire.routes.ts ---
import { Router } from "express";
import {
  createWire,
  getAllWires,
  getWireBalanceByType,
  deleteWire,
} from "../controllers/wire.controller";
import { authenticate, authorize } from "../middleware/auth";
import { Role } from "@prisma/client";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Wire
 *   description: Manage imported wires by kg
 */

router.use(authenticate);

/**
 * @swagger
 * /api/wires:
 *   post:
 *     summary: Import new wire
 *     tags: [Wire]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required: [wireType, quantityKg]
 *             properties:
 *               wireType:
 *                 type: string
 *               quantityKg:
 *                 type: number
 *     responses:
 *       201:
 *         description: Wire entry created
 */
router.post("/", authorize([Role.OWNER]), createWire);

/**
 * @swagger
 * /api/wires:
 *   get:
 *     summary: List all wire imports
 *     tags: [Wire]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of wire imports
 */
router.get("/", authorize([Role.OWNER, Role.MANAGER]), getAllWires);

/**
 * @swagger
 * /api/wires/balance/{wireType}:
 *   get:
 *     summary: Get remaining kg for a wire type
 *     tags: [Wire]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: wireType
 *         in: path
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Remaining kg
 */
router.get("/balance/:wireType", authorize([Role.OWNER]), getWireBalanceByType);

/**
 * @swagger
 * /api/wires/{id}:
 *   delete:
 *     summary: Delete wire entry
 *     tags: [Wire]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *     responses:
 *       204:
 *         description: Deleted
 */
router.delete("/:id", authorize([Role.OWNER]), deleteWire);

export default router;


--- File: src\services\auth.service.ts ---
import bcrypt from "bcryptjs";
import { prisma } from "../config/prisma";
import { generateToken } from "../utils/jwt";
import { Role } from "@prisma/client";

interface RegisterInput {
  name: string;
  email: string;
  phone: string;
  address: string;
  password: string;
  role: Role;
}

export const registerUser = async (input: RegisterInput) => {
  const { email, password } = input;

  const exists = await prisma.user.findUnique({ where: { email } });
  if (exists) throw { status: 400, message: "Email already registered" };

  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await prisma.user.create({
    data: { ...input, password: hashedPassword },
  });

  const token = generateToken(user.id);

  return { token, user };
};

interface LoginInput {
  email: string;
  password: string;
}

export const loginUser = async ({ email, password }: LoginInput) => {
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) throw { status: 401, message: "User not found" };

  const match = await bcrypt.compare(password, user.password);
  if (!match) throw { status: 401, message: "Invalid password" };

  const token = generateToken(user.id);

  return { token, user };
};


--- File: src\services\client.service.ts ---
import { prisma } from "../config/prisma";

export const createClient = async (data: any) => {
  return prisma.client.create({ data });
};

export const getAllClients = async () => {
  return prisma.client.findMany({
    orderBy: { createdAt: "desc" },
  });
};

export const getClientById = async (id: string) => {
  const client = await prisma.client.findUnique({ where: { id } });
  if (!client) throw { status: 404, message: "Client not found" };
  return client;
};

export const updateClient = async (id: string, data: any) => {
  return prisma.client.update({ where: { id }, data });
};

export const deleteClient = async (id: string) => {
  return prisma.client.delete({ where: { id } });
};


--- File: src\services\finance.service.ts ---
import { prisma } from "../config/prisma";

export const createFinanceEntry = async (data: {
  type: "income" | "expense";
  category: string;
  amount: number;
  description?: string;
}) => {
  return prisma.finance.create({ data });
};

export const getAllFinance = async () => {
  return prisma.finance.findMany({
    orderBy: { createdAt: "desc" },
  });
};

export const getFinanceByMonth = async (month: string) => {
  const [year, m] = month.split("-").map(Number);
  const from = new Date(year, m - 1, 1);
  const to = new Date(year, m, 1);

  return prisma.finance.findMany({
    where: {
      createdAt: {
        gte: from,
        lt: to,
      },
    },
    orderBy: { createdAt: "desc" },
  });
};

export const deleteFinanceEntry = async (id: string) => {
  return prisma.finance.delete({ where: { id } });
};


--- File: src\services\invoice.service.ts ---
// services/invoice.service.ts
import { prisma } from "../config/prisma";
import { calculateInvoiceTotal } from "../utils/calculate";
import { generateInvoicePDF } from "../utils/pdf";
import { sendEmail } from "../utils/mail";
import fs from "fs";

export const createInvoice = async (
  sellerId: string,
  input: {
    clientId: string;
    meshTypeId: string;
    quantity: number;
    pricePerUnit: number;
    amountPaid?: number;
  }
) => {
  const mesh = await prisma.meshType.findUnique({
    where: { id: input.meshTypeId },
  });
  if (!mesh) throw { status: 404, message: "Mesh type not found" };

  if (mesh.currentStock < input.quantity) {
    throw { status: 400, message: "Not enough mesh in stock" };
  }

  const total = calculateInvoiceTotal(input.quantity, input.pricePerUnit);
  const paid = input.amountPaid || 0;
  const due = total - paid;

  const invoice = await prisma.invoice.create({
    data: {
      sellerId,
      clientId: input.clientId,
      meshTypeId: input.meshTypeId,
      quantity: input.quantity,
      pricePerUnit: input.pricePerUnit,
      total,
      amountPaid: paid,
      dueAmount: due,
      isPaid: due <= 0,
    },
  });

  await prisma.meshType.update({
    where: { id: input.meshTypeId },
    data: {
      currentStock: { decrement: input.quantity },
    },
  });

  return invoice;
};

export const getAllInvoices = async () => {
  return prisma.invoice.findMany({
    include: {
      meshType: true,
      client: true,
      seller: true,
    },
    orderBy: { createdAt: "desc" },
  });
};

export const getInvoiceById = async (id: string) => {
  const invoice = await prisma.invoice.findUnique({
    where: { id },
    include: {
      meshType: true,
      client: true,
      seller: true,
    },
  });
  if (!invoice) throw { status: 404, message: "Invoice not found" };
  return invoice;
};

export const deleteInvoice = async (id: string) => {
  return prisma.invoice.delete({ where: { id } });
};

export const addPayment = async (invoiceId: string, amount: number) => {
  const invoice = await prisma.invoice.findUnique({ where: { id: invoiceId } });
  if (!invoice) throw { status: 404, message: "Invoice not found" };

  await prisma.paymentLog.create({
    data: { invoiceId, amount },
  });

  const newAmountPaid = invoice.amountPaid + amount;
  const newDue = invoice.total - newAmountPaid;

  return prisma.invoice.update({
    where: { id: invoiceId },
    data: {
      amountPaid: newAmountPaid,
      dueAmount: newDue,
      isPaid: newDue <= 0,
    },
  });
};

export const getInvoicePDF = async (invoiceId: string): Promise<Buffer> => {
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId },
    include: { client: true, meshType: true, seller: true },
  });

  if (!invoice) throw { status: 404, message: "Invoice not found" };

  const filePath = `/tmp/invoice-${invoiceId}.pdf`;
  await generateInvoicePDF(invoice, filePath);
  return fs.readFileSync(filePath);
};

export const emailInvoice = async (invoiceId: string) => {
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId },
    include: { client: true, meshType: true, seller: true },
  });

  if (!invoice || !invoice.client?.email) {
    throw { status: 400, message: "No client email available" };
  }

  const filePath = `/tmp/invoice-${invoiceId}.pdf`;
  await generateInvoicePDF(invoice, filePath);

  await sendEmail(
    invoice.client.email,
    `Invoice for mesh purchase`,
    `<p>Dear ${invoice.client.name},<br/>Please find attached your invoice.</p>`,
    [{ filename: "invoice.pdf", path: filePath }]
  );
};


--- File: src\services\machine.service.ts ---
import { prisma } from "../config/prisma";

export const createMachine = async (data: {
  name: string;
  description?: string;
}) => {
  return prisma.machine.create({ data });
};

export const getAllMachines = async () => {
  return prisma.machine.findMany({ orderBy: { createdAt: "desc" } });
};

export const getMachineById = async (id: string) => {
  const machine = await prisma.machine.findUnique({ where: { id } });
  if (!machine) throw { status: 404, message: "Machine not found" };
  return machine;
};

export const updateMachine = async (id: string, data: any) => {
  return prisma.machine.update({ where: { id }, data });
};

export const deleteMachine = async (id: string) => {
  return prisma.machine.delete({ where: { id } });
};

export const createMachineLog = async (
  machineId: string,
  userId: string,
  log: { startedAt: string; endedAt?: string }
) => {
  return prisma.machineLog.create({
    data: {
      machineId,
      userId,
      startedAt: new Date(log.startedAt),
      endedAt: log.endedAt ? new Date(log.endedAt) : null,
    },
  });
};

export const getMachineLogs = async (machineId: string) => {
  return prisma.machineLog.findMany({
    where: { machineId },
    include: { user: true },
    orderBy: { startedAt: "desc" },
  });
};


--- File: src\services\mesh.service.ts ---
import { prisma } from "../config/prisma";

export const createMeshType = async (data: any) => {
  return prisma.meshType.create({ data });
};

export const getAllMeshTypes = async () => {
  return prisma.meshType.findMany({
    orderBy: { createdAt: "desc" },
  });
};

export const getMeshTypeById = async (id: string) => {
  const mesh = await prisma.meshType.findUnique({ where: { id } });
  if (!mesh) throw { status: 404, message: "Mesh type not found" };
  return mesh;
};

export const updateMeshType = async (id: string, data: any) => {
  return prisma.meshType.update({ where: { id }, data });
};

export const deleteMeshType = async (id: string) => {
  return prisma.meshType.delete({ where: { id } });
};


--- File: src\services\production.service.ts ---
import { prisma } from "../config/prisma";
import { calculateWireUsageKg } from "../utils/calculate";

export const createProduction = async (
  userId: string,
  input: {
    meshTypeId: string;
    quantity: number;
    startedAt: string;
    finishedAt: string;
  }
) => {
  const meshType = await prisma.meshType.findUnique({
    where: { id: input.meshTypeId },
  });
  if (!meshType) throw { status: 404, message: "Mesh type not found" };

  const wireUsedKg = calculateWireUsageKg(
    input.quantity,
    meshType.weightPerPiece
  );

  // Find matching wire to deduct from
  const wires = await prisma.wire.findMany({
    where: { wireType: meshType.wireType },
    orderBy: { createdAt: "asc" },
  });

  let remainingToUse = wireUsedKg;
  for (const wire of wires) {
    const available = wire.quantityKg - wire.usedKg;
    if (available <= 0) continue;

    const deduct = Math.min(available, remainingToUse);
    await prisma.wire.update({
      where: { id: wire.id },
      data: { usedKg: { increment: deduct } },
    });

    remainingToUse -= deduct;
    if (remainingToUse <= 0) break;
  }

  if (remainingToUse > 0)
    throw { status: 400, message: "Not enough wire in stock" };

  // Save production log
  const production = await prisma.production.create({
    data: {
      userId,
      meshTypeId: input.meshTypeId,
      quantity: input.quantity,
      startedAt: new Date(input.startedAt),
      finishedAt: new Date(input.finishedAt),
    },
  });

  // Update mesh stock
  await prisma.meshType.update({
    where: { id: input.meshTypeId },
    data: {
      currentStock: { increment: input.quantity },
    },
  });

  return production;
};

export const getAllProductions = async () => {
  return prisma.production.findMany({
    include: {
      user: true,
      meshType: true,
    },
    orderBy: { createdAt: "desc" },
  });
};

export const getProductionByDate = async (date: string) => {
  const day = new Date(date);
  const nextDay = new Date(day);
  nextDay.setDate(day.getDate() + 1);

  return prisma.production.findMany({
    where: {
      createdAt: {
        gte: day,
        lt: nextDay,
      },
    },
    include: {
      user: true,
      meshType: true,
    },
  });
};


--- File: src\services\report.service.ts ---
// services/report.service.ts
import { prisma } from "../config/prisma";

export const getTopSellingMeshes = async () => {
  const results = await prisma.invoice.groupBy({
    by: ["meshTypeId"],
    _sum: { quantity: true, total: true },
    orderBy: { _sum: { quantity: "desc" } },
    take: 5,
  });

  const withNames = await Promise.all(
    results.map(async (r) => {
      const mesh = await prisma.meshType.findUnique({
        where: { id: r.meshTypeId },
      });
      return {
        meshType: mesh?.type || "Unknown",
        quantitySold: r._sum.quantity,
        revenue: r._sum.total,
      };
    })
  );

  return withNames;
};

export const getTopClients = async () => {
  const results = await prisma.invoice.groupBy({
    by: ["clientId"],
    _sum: { total: true },
    orderBy: { _sum: { total: "desc" } },
    take: 5,
  });

  const withClients = await Promise.all(
    results.map(async (r) => {
      const client = await prisma.client.findUnique({
        where: { id: r.clientId },
      });
      return {
        clientName: client?.name || "Unknown",
        totalSpent: r._sum.total,
      };
    })
  );

  return withClients;
};

export const getTopWorkers = async () => {
  const results = await prisma.production.groupBy({
    by: ["userId"],
    _sum: { quantity: true },
    orderBy: { _sum: { quantity: "desc" } },
    take: 5,
  });

  const withNames = await Promise.all(
    results.map(async (r) => {
      const user = await prisma.user.findUnique({ where: { id: r.userId } });
      return {
        workerName: user?.name || "Unknown",
        totalProduced: r._sum.quantity,
      };
    })
  );

  return withNames;
};

export const getCurrentStock = async () => {
  const meshes = await prisma.meshType.findMany({
    select: { type: true, currentStock: true, stockThreshold: true },
  });

  return meshes.map((m) => ({
    type: m.type,
    currentStock: m.currentStock,
    stockThreshold: m.stockThreshold,
    lowStock: m.currentStock <= (m.stockThreshold || 0),
  }));
};

export const getWireEfficiency = async () => {
  const wires = await prisma.wire.findMany();
  const usedKg = wires.reduce((sum, w) => sum + w.usedKg, 0);
  const totalKg = wires.reduce((sum, w) => sum + w.quantityKg, 0);

  const efficiency = totalKg > 0 ? (usedKg / totalKg) * 100 : 0;

  return {
    totalWire: totalKg,
    usedWire: usedKg,
    efficiencyPercent: efficiency.toFixed(2),
  };
};


--- File: src\services\salary.service.ts ---
import { prisma } from "../config/prisma";
import { startOfMonth, endOfMonth } from "date-fns";

export const createSalary = async (input: {
  userId: string;
  month: string;
  amount?: number;
}) => {
  const existing = await prisma.salary.findFirst({
    where: { userId: input.userId, month: input.month },
  });
  if (existing)
    throw { status: 400, message: "Salary already exists for this month" };

  let calculatedAmount = input.amount;

  const user = await prisma.user.findUnique({ where: { id: input.userId } });
  if (!user) throw { status: 404, message: "User not found" };

  if (!input.amount && user.role === "WORKER") {
    const monthStart = startOfMonth(new Date(input.month));
    const monthEnd = endOfMonth(new Date(input.month));

    const productions = await prisma.production.findMany({
      where: {
        userId: input.userId,
        createdAt: {
          gte: monthStart,
          lte: monthEnd,
        },
      },
      include: { meshType: true },
    });

    calculatedAmount = productions.reduce((total, prod) => {
      return total + prod.quantity * (prod.meshType?.priceForWorker || 0);
    }, 0);
  }

  return prisma.salary.create({
    data: {
      userId: input.userId,
      month: input.month,
      amount: calculatedAmount || 0,
    },
  });
};

export const getAllSalaries = async () => {
  return prisma.salary.findMany({
    include: { user: true },
    orderBy: { createdAt: "desc" },
  });
};

export const getSalariesByMonth = async (month: string) => {
  return prisma.salary.findMany({
    where: { month },
    include: { user: true },
  });
};

export const markSalaryAsPaid = async (id: string) => {
  return prisma.salary.update({
    where: { id },
    data: { paid: true },
  });
};


--- File: src\services\user.service.ts ---
import { prisma } from "../config/prisma";
import { Role } from "@prisma/client";

export const getAllUsers = async () => {
  return prisma.user.findMany({
    where: { NOT: { role: Role.OWNER } },
    select: {
      id: true,
      name: true,
      email: true,
      phone: true,
      address: true,
      role: true,
      createdAt: true,
    },
  });
};

export const getUserById = async (id: string) => {
  const user = await prisma.user.findUnique({ where: { id } });
  if (!user) throw { status: 404, message: "User not found" };
  return user;
};

export const updateUser = async (id: string, data: any) => {
  return prisma.user.update({
    where: { id },
    data,
  });
};

export const deleteUser = async (id: string) => {
  return prisma.user.delete({ where: { id } });
};


--- File: src\services\wire.service.ts ---
import { prisma } from "../config/prisma";

export const createWire = async (data: {
  wireType: string;
  quantityKg: number;
}) => {
  return prisma.wire.create({
    data: {
      wireType: data.wireType,
      quantityKg: data.quantityKg,
    },
  });
};

export const getAllWires = async () => {
  return prisma.wire.findMany({
    orderBy: { createdAt: "desc" },
  });
};

export const deleteWire = async (id: string) => {
  return prisma.wire.delete({ where: { id } });
};

export const getRemainingWireByType = async (wireType: string) => {
  const wires = await prisma.wire.findMany({
    where: { wireType },
  });

  const total = wires.reduce((sum, w) => sum + w.quantityKg, 0);
  const used = wires.reduce((sum, w) => sum + w.usedKg, 0);
  return total - used;
};


--- File: src\types\express.d.ts ---
import { User } from "@prisma/client";

declare global {
  namespace Express {
    interface Request {
      user?: User;
      lang?: Lang;
    }
  }
}


--- File: src\types\role.enum.ts ---
export enum Role {
  OWNER = "OWNER",
  MANAGER = "MANAGER",
  WORKER = "WORKER",
  DRIVER = "DRIVER",
  COOK = "COOK",
}


--- File: src\utils\calculate.ts ---
export const calculateWorkerSalary = (
  quantity: number,
  pricePerUnit: number
): number => quantity * pricePerUnit;

export const calculateWireUsageKg = (
  quantity: number,
  weightPerPiece: number
): number => quantity * weightPerPiece;

export const calculateInvoiceTotal = (
  quantity: number,
  pricePerUnit: number
): number => quantity * pricePerUnit;


--- File: src\utils\jwt.ts ---
import jwt from "jsonwebtoken";
import { ENV } from "../config/env";

export const generateToken = (id: string): string => {
  return jwt.sign({ id }, ENV.JWT_SECRET, {
    expiresIn: ENV.JWT_EXPIRES_IN, // can be string like '7d'
  } as jwt.SignOptions);
};

export const verifyToken = (token: string) => {
  return jwt.verify(token, ENV.JWT_SECRET);
};


--- File: src\utils\mail.ts ---
import nodemailer from "nodemailer";
import { ENV } from "../config/env";

export const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

export const sendEmail = async (
  to: string,
  subject: string,
  html: string,
  attachments?: any[]
) => {
  return transporter.sendMail({
    from: ENV.EMAIL_FROM,
    to,
    subject,
    html,
    attachments,
  });
};


--- File: src\utils\pdf.ts ---
import PDFDocument from "pdfkit";
import fs from "fs";
import { t } from "../i18n/messages";
import { Lang } from "../i18n/messages";

export const generateInvoicePDF = async (
  invoiceData: any,
  outputPath: string,
  lang: string = "en"
): Promise<void> => {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument();
    const stream = fs.createWriteStream(outputPath);

    doc.pipe(stream);

    doc
      .fontSize(20)
      .text(t("invoice.title", lang as Lang), { align: "center" });
    doc.moveDown();
    doc
      .fontSize(14)
      .text(`${t("invoice.client", lang as Lang)}: ${invoiceData.clientName}`);
    doc.text(`${t("invoice.meshType", lang as Lang)}: ${invoiceData.meshType}`);
    doc.text(`${t("invoice.quantity", lang as Lang)}: ${invoiceData.quantity}`);
    doc.text(
      `${t("invoice.unitPrice", lang as Lang)}: ${invoiceData.pricePerUnit}`
    );
    doc.text(`${t("invoice.total", lang as Lang)}: ${invoiceData.total}`);
    doc.text(
      `${t("invoice.date", lang as Lang)}: ${new Date(
        invoiceData.createdAt
      ).toLocaleDateString(lang)}`
    );

    doc.end();

    stream.on("finish", () => resolve());
    stream.on("error", (err) => reject(err));
  });
};


--- File: tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ES6", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "libReplacement": true,                           /* Enable lib replacement. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "commonjs", /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "node", /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    "rootDirs": [
      "./src"
    ], /* Allow multiple folders to be treated as one when resolving modules. */
    "typeRoots": [
      "src/types",
      "./node_modules/@types"
    ], /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist", /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "erasableSyntaxOnly": true,                       /* Do not allow runtime constructs that are not part of ECMAScript. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
    /* Type Checking */
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "include": [
    "src",
    "src/types",
    "scripts"
  ]
}